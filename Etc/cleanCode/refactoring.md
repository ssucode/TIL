# 리팩토링, Refactoring 이란?

### 사전적 의미로는 ‘결과의 변경 없이 코드의 구조를 재조정한다.’

리팩토링은

1. **코드의 가독성과 유지보수성을 높이기 위해**
2. **여러사람이 이해하는 코드를 작성하기 위해**

이미 작성한 소스코드를 구현된 일련의 행위들을 변경없이  내부구조를 변경하는것입니다.

### 주의해야 할 점! 혼돈하지 말아야 할점!

가독성과 유지보수성을 개선하는 것이지,

1. **기능을 변경하거나 추가**
2. **버그를 수정**
3. **성능을 개선**
4. **의존성을 업데이트**

하는것은 아닙니다.

### 리팩토링을 왜?

1. 버그를 찾는데 도움
2. 중복을 제거함으로써 작업코드가 한곳에서 존재함
3. 소프트웨어를 더 이해하기 쉽게 도움
4. 개발 속도가 향상

### 리팩토링은 언제?

1. 삼진 규칙(3번의 중복 / 3번의 같은 행위를 한다면 리팩토링 가자!)
2. 기능을 추가할 때
3. 버그를 수정해야 할 때
4. 코드 검토(Code Review)를 할 때

### 리팩토링은 어떻게?

기존 기능과 동작을 유지하기 위해 테스트 코드가 필요합니다.

테스트 코드가 없다면,

1. 기존 기능과 동작을 유지하는지 알수 없음
2. 일일이 어플리케이션 실행하면서 확인하여야 함

> **이때 중요한 점!**
소스코드에 버그가 있더라도 그대로 진행하고 리팩토리 진행한 이후에 버그를 수정합니다.
> 

### **이렇게들 말합니다.**

> ***더러운 소스코드의 악취를 제거하기 위해 남의 짠 소스 내가 고치고, 내가 짠 소스 내가 고친다.***
> 

---

### 냄새의 원인을 찾아 봅니다~! ****Code Smells~!****

1. **기이한 이름(Mysterious Name)**
    
    이름만 보고도 무슨 일을 하는 함수인지, 어떤 데이터를 가진 변수인지, 어떤 것들을 처리하는 클래스인지 알 수 있어야 하지만 전혀 알수 없는 이름 입니다.
    
2. **중복된 코드(Dunplicated Code)**
    
    • 똑같은 코드 구조가 두 군데 이상 있는 코드 입니다.
    
3. ****긴 메소드(Long Method)****
    
    메서드의 길이가 지나치게 길고 중복된 코드가 많은 코드입니다.
    
    - 메서드 길이가 10~20라인 정도로 작성하는 것이 좋습니다. (조직마다 기준을 다르게 가져갈 수 있음)
    - 메서드 명은 이해하기 쉽도록 목적을 나타내는 이름으로 정합니다.
4. ****거대한 클래스(Large Class)****
    
    인스턴스 변수가 너무 많거나 코드가 너무 많은 클래스 입니다.
    
    - 클래스나 서브클래스 또는 인터페이스로 추출하거나 데이터를 객체로 대체합니다.
5. ****긴 파라미터 리스트(Long Parameter List)****
    
    루틴에 필요한 대부분을 매개변수를 사용해 전달하는 경우. 이해하기 어렵고, 다른 데이터가 필요할 때마다 수정해야 합니다.
    
6. ****수정의 산발(Divergent Change)****
    
    한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정되는 경우입니다.
    
7. ****기능의 산재(Shotgun Surgery)****
    
    수정할 때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 하는 경우입니다.
    
8. ****잘못된 소속(Feature Envy)****
    
    어떤 모듈의 함수가 자기가 속한 모듈의 함수/데이터보다 다른 모듈의 함수/데이터를 자주 사용하는 경우입니다.
    
9. ****데이터 덩어리(Data Clump)****
    
    각각의 부분이 합쳐져서 하나의 구성 요소를 이루는 경우입니다.
    
    ex) 각각 다른 곳에 있는 이름, 나이, 성별 ··· → 사람
    
    - 클래스 추출, 파라미터 객체로 선언합니다.
10. ****기본 타입에 대한 강박관념(Primitive Obsession)****
    
    클래스 또는 레코드 유형이 더 잘 작동하도록 원시 데이터 유형을 사용하는 것이나 소규모 작업을 더 잘 처리하기 위해 소규모 클래스를 사용하는 것입니다.
    
11. ****Switch문(Switch Statements)****
    
    Switch문의 사용이 많은 경우 중복이 발생하여 유지보수성이 떨어집니다.
    
12. ****병렬 상속 계층(Parallel Inheritance Hierarchies)****
    
    한 클래스의 하위 클래스를 만들 때마다 다른 클래스의 하위 클래스를 만드는 것입니다.
    
13. **죽은 코드 (Dead Code)**
    
    더 이상 사용되지 않는 코드입니다.
    
14. ****게으른 클래스(Lazy Class)****
    
    유지보수를 정당화할만큼 충분한 작업을 하지 않고 있는 클래스입니다.
    
15. ****추측성 일반화(Speculative Generality)****
    
    나중에 필요할 경우를 대비하여 코드를 일반화하는 것 또는 사용하지 않는 훅과 특별한 경우로 인해 코드를 더 이해하기 어려워지는 경우입니다.
    
16. ****임시 필드(Temporary Field)****
    
    특정 상황에서만 설정된 인스턴스 변수 또는 중간 결과를 유지하는 데 사용되는 필드입니다.
    
17. ****메시지 체인 (Message Chains)****
    
    어떤 객체는 다른 객체에 무엇인가를 요구하고, 그 객체는 또 다른 객체에 요청하고, 또 다른 객체는 또또 다른 객체에 요청하는 일을 말합니다.
    
18. ****미들 맨 (Middle Man)****
    
    하나의 클래스가 많은 요청을 다른 클래스에 위임하는 것을 말합니다.
    
19. ****부적절한 친밀(Inappropriate Intimacy)****
    
    다른 클래스에서 private이여야 하는 항목을 많이 사용하는 클래스를 말합니다.
    
20. ****다른 인터페이스를 가진 대체 클래스(Alternative Classes with Different Interface)****
    
    동일한 작업을 수행하지만 특징이 다른 메소드입니다.
    
21. ****불완전한 라이브러리 클래스(Incomplete Library Class)****
    
    필요한 메소드를 제공하지 않는 라이브러리입니다.
    
22. ****데이터 클래스(Data Class)****
    
    필드와 각 필드에 대한 Getter / Setter 메서드만을 제공하고, 다른 것은 아무것도 없는 클래스입니다.
    
23. ****상속 포기 (Refused Bequest)****
    
    슈퍼클래스로부터 물려받은 것을 사용하지 않는 것을 말합니다.
    
24. ****주석(Comment)****
    
    직관적이지 않은 명칭으로 클래스/메서드/필드 등을 선언하여서 작성되는 주석도 불필요합니다.
    

---

****Reference****

• [https://refactoring.guru/refactoring/smells](https://refactoring.guru/refactoring/smells)
